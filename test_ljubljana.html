<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ljubljana Test - Real Location</title>
</head>
<body>
    <h1>Ljubljana Geocoding and Routing Test</h1>
    <p><strong>This test uses your REAL current location!</strong></p>
    <div id="results"></div>

    <script>
        // Test address
        const testAddress = "Ljubljana, Upravna Enota Ljubljana, Slovenia";

        async function testGeocoding() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<h2>Getting your current location...</h2>';

            try {
                // Get real current position
                console.log('Getting current location...');
                const currentPosition = await getCurrentPosition();
                console.log('Current position:', currentPosition);

                // Geocode current location to get address
                console.log('Geocoding current location...');
                const currentLocationAddress = await geocodeAddress(`${currentPosition.lat}, ${currentPosition.lng}`);
                console.log('Current location address:', currentLocationAddress);

                // Test 1: Geocoding Ljubljana
                console.log('Testing geocoding for:', testAddress);
                const geocodingResult = await geocodeAddress(testAddress);
                console.log('Geocoding result:', geocodingResult);

                // Test 2: OSRM Routing
                console.log('Testing OSRM routing...');
                const routeResult = await getRouteInfo(currentPosition, geocodingResult);
                console.log('OSRM route result:', routeResult);

                // Test 3: Haversine distance
                const haversineDistance = calculateDistance(
                    currentPosition.lat, currentPosition.lng,
                    geocodingResult.lat, geocodingResult.lng
                );
                console.log('Haversine distance:', haversineDistance);

                // Display results
                resultsDiv.innerHTML = `
                    <h2>Test Results</h2>
                    <h3>Your Current Location:</h3>
                    <p><strong>Address:</strong> ${currentLocationAddress.displayName}</p>
                    <p><strong>Coordinates:</strong> ${currentPosition.lat.toFixed(6)}, ${currentPosition.lng.toFixed(6)}</p>
                    
                    <h3>Destination:</h3>
                    <p><strong>Address:</strong> ${testAddress}</p>
                    <p><strong>Coordinates:</strong> ${geocodingResult.lat.toFixed(6)}, ${geocodingResult.lng.toFixed(6)}</p>
                    <p><strong>Display Name:</strong> ${geocodingResult.displayName}</p>
                    
                    <h3>Distance Calculations:</h3>
                    <p><strong>OSRM Route Distance:</strong> ${routeResult.distance.toFixed(2)} km</p>
                    <p><strong>OSRM Route Duration:</strong> ${routeResult.duration ? routeResult.duration.toFixed(1) + ' min' : 'N/A'}</p>
                    <p><strong>OSRM Average Speed:</strong> ${routeResult.averageSpeed ? routeResult.averageSpeed.toFixed(1) + ' km/h' : 'N/A'}</p>
                    <p><strong>Haversine (as crow flies):</strong> ${haversineDistance.toFixed(2)} km</p>
                    
                    <h3>Difference:</h3>
                    <p><strong>OSRM vs Haversine:</strong> ${(routeResult.distance - haversineDistance).toFixed(2)} km difference</p>
                    <p><strong>Route Efficiency:</strong> ${((haversineDistance / routeResult.distance) * 100).toFixed(1)}% (higher = more direct)</p>
                    
                    <h3>Road Types (OSRM):</h3>
                    <p><strong>Road Analysis:</strong> ${routeResult.roadTypes ? JSON.stringify(routeResult.roadTypes, null, 2) : 'N/A'}</p>
                `;

            } catch (error) {
                console.error('Test failed:', error);
                resultsDiv.innerHTML = `<h2>Test Failed</h2><p>Error: ${error.message}</p><p>Make sure you allow location access in your browser.</p>`;
            }
        }

        // Get current position using browser geolocation
        function getCurrentPosition() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Geolocation is not supported by this browser'));
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                };

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve({
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            timestamp: position.timestamp
                        });
                    },
                    (error) => {
                        const errorMessage = getErrorMessage(error);
                        reject(new Error(errorMessage));
                    },
                    options
                );
            });
        }

        // Copy the geocoding function from geolocation.js
        async function geocodeAddress(address) {
            if (!address || address.trim() === '') {
                throw new Error('Address is required');
            }

            const encodedAddress = encodeURIComponent(address.trim());
            
            const services = [
                {
                    url: `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://nominatim.openstreetmap.org/search?format=json&q=${encodedAddress}&limit=1&addressdetails=1`)}`,
                    parser: (data) => {
                        if (data.length === 0) throw new Error('Address not found');
                        const result = data[0];
                        return {
                            lat: parseFloat(result.lat),
                            lng: parseFloat(result.lon),
                            displayName: result.display_name,
                            address: result.address
                        };
                    }
                },
                {
                    url: `https://geocode.maps.co/search?q=${encodedAddress}`,
                    parser: (data) => {
                        if (data.length === 0) throw new Error('Address not found');
                        const result = data[0];
                        return {
                            lat: parseFloat(result.lat),
                            lng: parseFloat(result.lon),
                            displayName: result.display_name || `${address}, Netherlands`,
                            address: result.address || address
                        };
                    }
                }
            ];

            for (const service of services) {
                try {
                    const response = await fetch(service.url, {
                        headers: {
                            'Accept': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        continue;
                    }

                    const data = await response.json();
                    const result = service.parser(data);
                    
                    console.log('Geocoding successful:', result);
                    return result;
                    
                } catch (error) {
                    console.log(`Geocoding service failed:`, error.message);
                    continue;
                }
            }

            throw new Error(`Could not find address: ${address}. Please try a different address or check your internet connection.`);
        }

        // Copy the routing function from geolocation.js
        async function getRouteInfo(origin, destination) {
            try {
                const url = `https://router.project-osrm.org/route/v1/driving/${origin.lng},${origin.lat};${destination.lng},${destination.lat}?overview=false&annotations=true`;
                
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('OSRM route request failed');
                }
                
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    const route = data.routes[0];
                    const leg = route.legs[0];
                    
                    return {
                        distance: route.distance / 1000, // Convert to kilometers
                        duration: route.duration / 60, // Convert to minutes
                        averageSpeed: (route.distance / 1000) / (route.duration / 3600), // km/h
                        roadTypes: analyzeRoadTypes(leg.annotation?.speed || []),
                        waypoints: leg.annotation?.speed || []
                    };
                } else {
                    throw new Error('No route found');
                }
            } catch (error) {
                console.warn('OSRM route calculation failed, falling back to Haversine:', error.message);
                const distance = calculateDistance(origin.lat, origin.lng, destination.lat, destination.lng);
                return {
                    distance: distance,
                    duration: null,
                    averageSpeed: null,
                    roadTypes: null,
                    waypoints: null
                };
            }
        }

        // Copy the distance calculation function
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in kilometers
            const dLat = toRadians(lat2 - lat1);
            const dLng = toRadians(lng2 - lng1);
            
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) *
                      Math.sin(dLng / 2) * Math.sin(dLng / 2);
            
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c;
            
            return distance;
        }

        // Copy helper functions
        function analyzeRoadTypes(speedData) {
            if (!speedData || speedData.length === 0) return null;
            
            const roadTypes = {
                highway: 0,
                primary: 0,
                secondary: 0,
                residential: 0
            };
            
            speedData.forEach(speed => {
                if (speed > 100) roadTypes.highway++;
                else if (speed > 80) roadTypes.primary++;
                else if (speed > 50) roadTypes.secondary++;
                else roadTypes.residential++;
            });
            
            return roadTypes;
        }

        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        function getErrorMessage(error) {
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    return 'Location access denied. Please check your browser settings.';
                case error.POSITION_UNAVAILABLE:
                    return 'Location information is unavailable.';
                case error.TIMEOUT:
                    return 'Location request timed out. Please try again.';
                default:
                    return 'An unknown error occurred.';
            }
        }

        // Run the test
        testGeocoding();
    </script>
</body>
</html> 